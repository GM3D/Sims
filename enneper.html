<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Enneper's Rieman Surface</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
        <!-- <p id="info">window_size (x, y), point position (x, y), w position (x, y)</p> -->
		<script src="js/three.js"></script>
		<script>
         var PI = Math.PI;
         var scene1, scene2, 
             camera1, camera2, renderer;
         var point, point2;
         var point_geom = new THREE.CircleGeometry(0.05, 16);
         var mat_black = new THREE.MeshBasicMaterial({color: 0x000000});
         point2 = new THREE.Mesh(point_geom, mat_black);
         
         // guiding lines
         var gl1, gl2;
         var gl1_geom = new THREE.Path();
         var gl2_geom = new THREE.Path();
         

         var width = window.innerWidth;
         var height = window.innerHeight;
         // 0.0 <= aspect <= 1.0
         var aspect = height / width;
         // r; world scale. world width is exactly 2 * r
         var r = 5.0;
         // previous w position and increment from current position.
         var w, prev, delta;
         // displacement and it's angle from 1, -1, i, -i respectively
         var v, args0, args, prev_args;
         var p, ps = [0, -1, 0, 1, -1, 0, 1, 0];


         init();
         animate();

         function init(){
             w = new THREE.Vector2(0, 0);
             prev = new THREE.Vector2(0, 0);
             delta = new THREE.Vector2(0, 0);
             v = [];
             p = [];
             for(i = 0; i < 4; i++){
                 v[i] = new THREE.Vector2();
                 p[i] = new THREE.Vector2(ps[2 * i], ps[2*i + 1]);
             }
             args0 = [PI/2, 3*PI/2, 0, -PI];
             args = [PI/2, 3*PI/2, 0, -PI];
             prev_args = [PI/2, 3*PI/2, 0, -PI];
             renderer = new THREE.WebGLRenderer();
             renderer.setSize(width, height);
             document.addEventListener('mousemove', 
                                       onDocumentMouseMove, false);
             document.body.appendChild(renderer.domElement);
             scene1 = new THREE.Scene();
             scene2 = new THREE.Scene();
             setup_scene1();
             setup_scene2();
             camera1 = new 
             THREE.OrthographicCamera(-r / 2, r / 2, 
                                      r * aspect, -r * aspect,
                                      1, 1000);
             camera1.position.z = 5;
             scene1.add(camera1);
             camera2 = new 
             THREE.OrthographicCamera(-r /2 , r / 2 ,
                                      r * aspect, -r * aspect,
                                      1, 1000);
             camera2.position.z = 5;
             scene2.add(camera2);
             console.log("end of initialization.");
         }

         function setup_scene1(){
             var geometry = new THREE.PlaneGeometry(4, 4);
             var point_geom = new THREE.CircleGeometry(0.05, 16);
             var mat_ivory = new THREE.MeshBasicMaterial({color: 0xffeeff});
             var mat_black = new THREE.MeshBasicMaterial({color: 0x000000});
             var w_plane = new THREE.Mesh(geometry, mat_ivory);
             scene1.add(w_plane);
             point = new THREE.Mesh(point_geom, mat_black);
             scene1.add(point);
             draw_cuts(0, 0, 1.0);
             /* draw_aux_lines();*/
             label_data1 = [
                 {text: "+1", bg_color: "0xffeeff",
                  top: 0.5 - 0.01, left: 3/8 - 0.01},
                 {text: "-1", bg_color: "0xffeeff",
                  top: 0.5 - 0.01, left: 1/8 - 0.01},
                 {text: "+i", bg_color: "0xffeeff",
                  top: 0.33 - 0.01, left: 1/4 - 0.01},
                 {text: "-i", bg_color: "0xffeeff",
                  top: 0.67 - 0.01, left: 1/4 - 0.01}
             ];
             setup_labels(label_data1);
         }

         function setup_scene2(){
             var colors = [0xFFFFFF, 0xBBBBFF];
             var geometry = new THREE.PlaneGeometry(1, 1);
             var i0 = 4
             var j0 = 4;
             var xy_tiles = [];
             for(i = 0; i < i0; i++){
                 xy_tiles[i] = [];
                 for(j = 0; j < j0; j++){
                     var color_opt = {color: colors[(i + j) % 2]};
                     var mat = new THREE.MeshBasicMaterial(color_opt);
                     xy_tiles[i][j] = new THREE.Mesh(geometry, mat);
                     xy_tiles[i][j].position.set(i - i0 / 2 + 0.5,
                                                 j - j0 / 2 + 0.5,
                                                 0);
                     scene2.add(xy_tiles[i][j]);
                 }
             }
             label_data = [];
             for(i = 0; i < i0; i++){
                 for(j = 0; j < j0; j++){
                     if((i + j)%2 == 1){
                         label_data.push({
                             text: "S(" + (1 - i) + ", " + (j - 2) + ")",
                             bg_color: colors[(i + j) % 2],
                             top: i * 0.2 + 0.19,
                             left: j * 0.1 + 0.59});
                     }
                 }
             }
             setup_labels(label_data);
             scene2.add(point2);
         }

         function setup_labels(label_data){
             var labels = []
             for(i = 0; i < label_data.length; i++){
                 labels.push(document.createElement('div'));
                 labels[i].style.position = 'absolute';
                 labels[i].style.width = 100;
                 labels[i].style.height = 100;
                 labels[i].style.backgroundColor = label_data[i].bg_color;
                 labels[i].innerHTML = label_data[i].text;
                 labels[i].style.top = height * label_data[i].top + 'px';
                 labels[i].style.left = width * label_data[i].left + 'px';
                 document.body.appendChild(labels[i]);
             }
         }

         function draw_cuts(x, y, r){
             var circle_width = 4;
             var z = 1;
             draw_arc(x, y, r,
                         0, PI / 2, 
                         {color: 0xFF0000}, circle_width, true);
             draw_arc(x, y, r,
                         PI / 2, PI,
                         {color: 0x808080}, circle_width, true);
             draw_arc(x, y, r,
                         PI, PI * 1.5,
                         {color: 0x00FF00}, circle_width, true);
             draw_arc(x, y, r,
                         PI * 1.5, PI * 2.0,
                         {color: 0x0000FF}, circle_width, true);
             var color_white = {color: 0xFFFFFF};
             var color_black = {color: 0x000000};
             var r_pole = 0.05, width_pole = 4;
             draw_lined_circle(x - r, y, r_pole, width_pole,
                               color_white, color_black);
             draw_lined_circle(x + r, y, r_pole, width_pole,
                               color_white, color_black);
             draw_lined_circle(x, y - r, r_pole, width_pole,
                               color_white, color_black);
             draw_lined_circle(x, y + r, r_pole, width_pole,
                               color_white, color_black);
         }
         
         function draw_aux_lines(){
             var width = 1;

             var color1 = {color: 0x0000AA};
             var line_mat1 = new THREE.LineBasicMaterial(color1, width);
             var geometry1 = new THREE.Geometry();
             geometry1.vertices.push(p[0].x, p[0].y, 0);
             geometry1.vertices.push(w.x, w.y, 0);
             geometry1.vertices.push(p[1].x, p[1].y, 0);
             var line1 = new THREE.Line(geometry1, mat1);
             scene1.add(line1);

             var color2 = {color: 0xAA0000};
             var line_mat2 = new THREE.LineBasicMaterial(color2, width);
             var geometry2 = new THREE.Geometry();
             geometry2.vertices.push(p[2].x, p[2].y, 0);
             geometry2.vertices.push(w.x, w.y, 0);
             geometry2.vertices.push(p[3].x, p[3].y, 0);
             var line2 = new THREE.Line(geometry2, mat2);
             scene1.add(line2);
         }

         function draw_arc(x, y, r, start, end, color, width, dashed){
             var curve = new THREE.EllipseCurve(
                 x, y, r, r, start, end, false);
             var points = curve.getSpacedPoints(40);
             var path = new THREE.Path();
             var geometry = path.createGeometry(points);
             var material;
             options = {dashSize: 12, gapSize: 3};
             if(dashed){
                 material = new THREE.LineDashedMaterial(color, width);
             }else{
                 material = new THREE.LineBasicMaterial(color, width);
             }
             material.linewidth = width
             material.dashSize = 100;
             material.gapSize = 20;
             var line = new THREE.Line(geometry, material);
             scene1.add(line);
         }
         
         function draw_lined_circle(x, y, r, width, color1, color2)
         {
             var mat_color1 = new THREE.MeshBasicMaterial(color1);
             var mat_color2 = new THREE.MeshBasicMaterial(color2);
             var geom_pole = new THREE.CircleGeometry(r, 16);
             var pole = new THREE.Mesh(geom_pole, mat_color1);
             var z = 1.0;
             pole.position.set(x, y, z);
             draw_arc(x, y, r,
                      0, PI * 2, 
                      color2,
                      width, false);
             scene1.add(pole);
         }

         function onDocumentMouseMove(event){
             /* convert to cartesian coordinate */
             /* center = (0, 0), positive dir = up, right */
             prev.copy(w);
			 w.x = r * ((event.clientX / width) * 2 - 1) + r / 2;
             /* -r <= w.x < r */
			 w.y = r * (-(event.clientY - height / 2) / width) * 2;
             // delta = prev - w
             delta.subVectors(prev, w);
             /* -r * aspect  <= w.y < r * aspect */
             point.position.set(w.x, w.y, 0);
             /* document.getElementById("info").innerHTML = 
              *     "window size = (" + width + ", " + height + "), " +
              *     "event x: " + event.clientX + ", y: " + event.clientY +
              *     ", w x: " + w.x + ", y: " + w.y;*/
             for(i = 0; i < 4; i++){
                 v[i].subVectors(w, p[i]);
                 args0[i] = Math.atan2(v[i].y, v[i].x);
             }
             // 0 : w + i, 1: w - i, 2 : w + 1, 3: w - 1
             args0[0] = into_range(0, 2.0*PI, args0[0]);
             args0[1] = into_range(0, 2.0*PI, args0[1]);
             args0[2] = into_range(-0.5*PI, 1.5*PI, args0[2]);
             args0[3] = into_range(-0.5*PI, 1.5*PI, args0[3]);
             // dargs = small diff of args constrained to move
             // smoothly
             var dargs = [];
             for(i = 0; i < 4; i++){
                 var r2 = v[i].lengthSq();
                 prev_args[i] = args[i];
                 dargs[i] = (delta.x * v[i].y - delta.y * v[i].x) / r2;
                 args[i] += dargs[i]
             }
             // (x, y): mapped position of w in unit of pi
             var x = (args[0] - args[1]) / PI + 0.5;
             var y = (args[2] - args[3]) / PI + 0.5;
             console.log("w = " + w.toSource());
             console.log("prev = " + prev.toSource());
             console.log("delta = " + delta.toSource());
             console.log("r2 = " + r2);
             console.log("args0 = " + args0.toSource());
             console.log("dargs = " + dargs.toSource());
             console.log("args = " + args.toSource());
             console.log("x, y = " + x + ", " + y);
             point2.position.set(x, y, 0);
		 }
         
         function into_range(a, b, x){
             if(x < a){
                 x += 2 * PI;
             }else if(b <= x){
                 x -= 2 * PI;
             }
             return x;
         }

         function render(){
             // render left area
             renderer.setViewport(0, 0, 0.5 * width, height);
             renderer.setScissor(0, 0, 0.5 * width, height);
             renderer.setScissorTest(true);
	         renderer.render(scene1, camera1);
             // render right area
             renderer.setViewport(0.5 * width, 0, 0.5 * width, height);
             renderer.setScissor(0.5 * width, 0, 0.5 * width, height);
             renderer.setScissorTest(true);
	         renderer.render(scene2, camera2);
         }

         function update(){
         }

         function animate(){
	         requestAnimationFrame(animate);
             render();
             update();
             /* cube.rotation.x += 0.01;
              * cube.rotation.y += 0.01;*/
         }
		</script>
	</body>
</html>
