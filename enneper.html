<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Enneper's Rieman Surface</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
        <!-- <p id="info">window_size (x, y), point position (x, y), mouse position (x, y)</p> -->
		<script src="js/three.js"></script>
		<script>
         var container, mouse, scene1, scene2, 
             camera1, camera2, renderer;
         var point;
         var width = window.innerWidth;
         var height = window.innerHeight;
         // r; world scale. world width is exactly 2 * r
         var r = 5.0;
         // previous mouse position and increment from current position.
         var prev, delta;


         init();
         animate();

         function init(){
             mouse = new THREE.Vector2();
             prev = new THREE.Vector2();
             delta = new THREE.Vector2();
             var aspect = height / width;
             renderer = new THREE.WebGLRenderer();
             renderer.setSize(width, height);
             container = document.getElementById('ThreeJS');
             document.addEventListener('mousemove', 
                                       onDocumentMouseMove, false);
             document.body.appendChild(renderer.domElement);
             scene1 = new THREE.Scene();
             scene2 = new THREE.Scene();
             setup_scene1();
             setup_scene2();
             camera1 = new 
             THREE.OrthographicCamera(-r / 2, r / 2, 
                                      r * aspect, -r * aspect,
                                      1, 1000);
             camera1.position.z = 5;
             scene1.add(camera1);
             camera2 = new 
             THREE.OrthographicCamera(-r /2 , r / 2 ,
                                      r * aspect, -r * aspect,
                                      1, 1000);
             camera2.position.z = 5;
             scene2.add(camera2);
             console.log("end of initialization.");
         }

         function setup_scene1(){
             var geometry = new THREE.PlaneGeometry(4, 4);
             var point_geom = new THREE.CircleGeometry(0.05, 16);
             var material = new THREE.MeshBasicMaterial({color: 0xffeeff});
             var mat_black = new THREE.MeshBasicMaterial({color: 0x000000});
             var w_plane = new THREE.Mesh(geometry, material);
             scene1.add(w_plane);
             point = new THREE.Mesh(point_geom, mat_black);
             scene1.add(point);
             draw_cuts(0, 0, 1.0);
         }

         function setup_scene2(){
             var mat_checker = new Array(
                 new THREE.MeshBasicMaterial({color: 0xFFFFFF}),
                 new THREE.MeshBasicMaterial({color: 0xBBBBff}));
             var geometry = new THREE.PlaneGeometry(1, 1);
             xy_tiles = [];
             var i0 = 4, j0 = 4;
             for(i = 0; i < i0; i++){
                 xy_tiles.push([]);
                 for(j = 0; j < j0; j++){
                     xy_tiles[i].push(new THREE.Mesh(
                         geometry, mat_checker[(i + j) % 2]));
                     xy_tiles[i][j].position.set(i - i0 / 2 + 0.5,
                                                 j - j0 / 2 + 0.5,
                                                 0);
                     scene2.add(xy_tiles[i][j]);
                     
                 }
             }
             var point_geom = new THREE.CircleGeometry(0.05, 16);
             var mat_black = new THREE.MeshBasicMaterial({color: 0x000000});
             point2 = new THREE.Mesh(point_geom, mat_black);
             scene2.add(point2);
         }

         function draw_cuts(x, y, r){
             var circle_width = 4;
             var z = 1;
             draw_arc(x, y, r,
                         0, Math.PI / 2, 
                         {color: 0xFF0000}, circle_width, true);
             draw_arc(x, y, r,
                         Math.PI / 2, Math.PI,
                         {color: 0x808080}, circle_width, true);
             draw_arc(x, y, r,
                         Math.PI, Math.PI * 1.5,
                         {color: 0x00FF00}, circle_width, true);
             draw_arc(x, y, r,
                         Math.PI * 1.5, Math.PI * 2.0,
                         {color: 0x0000FF}, circle_width, true);
             var color_white = {color: 0xFFFFFF};
             var color_black = {color: 0x000000};
             var r_pole = 0.05, width_pole = 4;
             draw_lined_circle(x - r, y, r_pole, width_pole,
                               color_white, color_black);
             draw_lined_circle(x + r, y, r_pole, width_pole,
                               color_white, color_black);
             draw_lined_circle(x, y - r, r_pole, width_pole,
                               color_white, color_black);
             draw_lined_circle(x, y + r, r_pole, width_pole,
                               color_white, color_black);
         }
         
         function draw_arc(x, y, r, start, end, color, width, dashed){
             var curve = new THREE.EllipseCurve(
                 x, y, r, r, start, end, false);
             var points = curve.getSpacedPoints(40);
             var path = new THREE.Path();
             var geometry = path.createGeometry(points);
             var material;
             options = {dashSize: 12, gapSize: 3};
             if(dashed){
                 material = new THREE.LineDashedMaterial(color, width);
             }else{
                 material = new THREE.LineBasicMaterial(color, width);
             }
             material.linewidth = width
             material.dashSize = 100;
             material.gapSize = 20;
             var line = new THREE.Line(geometry, material);
             scene1.add(line);
         }
         
         function draw_lined_circle(x, y, r, width, color1, color2)
         {
             var mat_color1 = new THREE.MeshBasicMaterial(color1);
             var mat_color2 = new THREE.MeshBasicMaterial(color2);
             var geom_pole = new THREE.CircleGeometry(r, 16);
             var pole = new THREE.Mesh(geom_pole, mat_color1);
             var z = 1.0;
             pole.position.set(x, y, z);
             draw_arc(x, y, r,
                      0, Math.PI * 2, 
                      color2,
                      width, false);
             scene1.add(pole);
         }

         function onDocumentMouseMove(event){
             /* convert to cartesian coordinate */
             /* center = (0, 0), positive dir = up, right */
             prev = mouse;
			 mouse.x = r * ((event.clientX / width) * 2 - 1) + r / 2;
             /* -r <= mouse.x < r */
			 mouse.y = r * (-(event.clientY - height / 2) / width) * 2;
             delta = prev - mouse;
             /* -r * aspect  <= mouse.y < r * aspect */
             point.position.set(mouse.x, mouse.y, 0);
             /* document.getElementById("info").innerHTML = 
              *     "window size = (" + width + ", " + height + "), " +
              *     "event x: " + event.clientX + ", y: " + event.clientY +
              *     ", mouse x: " + mouse.x + ", y: " + mouse.y;*/
             point2.position.set(mouse.x, mouse.y, 0);
		 }
         
         function render(){
             // render left area
             renderer.setViewport(0, 0, 0.5 * width, height);
             renderer.setScissor(0, 0, 0.5 * width, height);
             renderer.setScissorTest(true);
	         renderer.render(scene1, camera1);
             // render right area
             renderer.setViewport(0.5 * width, 0, 0.5 * width, height);
             renderer.setScissor(0.5 * width, 0, 0.5 * width, height);
             renderer.setScissorTest(true);
	         renderer.render(scene2, camera2);
         }

         function update(){
         }

         function animate(){
	         requestAnimationFrame(animate);
             render();
             update();
             /* cube.rotation.x += 0.01;
              * cube.rotation.y += 0.01;*/
         }
		</script>
	</body>
</html>
